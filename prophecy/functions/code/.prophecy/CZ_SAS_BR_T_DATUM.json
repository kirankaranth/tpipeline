{"initCode":"","code":"\"\"\" UDF \"\"\"\n\nfrom pyspark.sql.functions import udf\nfrom pyspark.sql.types import DateType\n\n\n@udf(returnType=DateType())\ndef cz_sas_br_t_datum(param1, param2):\n    # this function evaluates the following code in SAS environment:\n    # COALESCE(INPUT(&&param1., ANYDTDTE.),INPUT(&&param2.,ANYDTDTE.))\n\n    # The minimum date supported by ANYDTDTE informat in SAS is January 1, 1582.\n    # This is consistent with the minimum date allowed in the Gregorian calendar,\n    # which is the standard calendar system used in most of the world today.\n\n    # For input '00090101', it must return the date '2009-Jan-01', as shows the DTR_MAR_Z405001001 job run.\n    # Function br_t_datum uses ANYDTDTE in SAS which supports min date\n    # 01JAN1582\n\n    # pylint: disable=import-outside-toplevel\n    from datetime import datetime as dt, date\n\n    def parse_date(param):\n        try:\n            if dt.strptime(param, \"%Y%m%d\").date() >= date(1582, 1, 1):\n                return dt.strptime(param, \"%Y%m%d\").date()\n\n            if param[:2] == \"00\":\n                value = dt.strptime(param, \"%Y%m%d\").date()\n\n                # by empirical tests we found that leading '00's up to (current year + 1)\n                # are recognized as (2000 + value.year), if the value exceeds (current year + 1) -\n                # it is recognized as (1900 + value.year)\n                # for example: '000190120' as of year 2024 will be parsed as '2019-01-20' and '00730120'\n                # will be parsed as '1973-01-20'\n\n                if value.year + 2000 <= date.today().year + 1:\n                    return dt(value.year + 2000, value.month, value.day).date()\n\n                return dt(value.year + 1900, value.month, value.day).date()\n\n            raise ValueError(\"Minimum value exception\")\n        except ValueError:\n            if dt.strptime(param, \"%d%m%Y\").date() >= date(1582, 1, 1):\n                return dt.strptime(param, \"%d%m%Y\").date()\n\n            raise\n\n    param1 = \"\" if not param1 else param1\n    param2 = \"\" if not param2 else param2\n\n    try:\n        result = parse_date(param1)\n    except ValueError:\n        try:\n            result = parse_date(param2)\n        except ValueError as e:\n            print(f\"An exception occurred: {str(e)}\")\n            result = None\n\n    if result and 0 < result.year < 10:\n        result = dt(result.year + 2000, result.month, result.day).date()\n\n    return result\n"}